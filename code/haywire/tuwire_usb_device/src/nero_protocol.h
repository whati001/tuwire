/*
 * Apple Nero protocol documentation
 */
#if PROTOCOL_CHECK == 1

/*
 * GENERAL:
 *  The Nero protocol is leveraged by the official Apple Lightning Digital AV Adapter to request the screen content
 *  https://www.apple.com/at/shop/product/MD826ZM/A/lightning-digital-av-adapter
 *
 * RESOURCES:
 *  - https://github.com/danielpaulus/quicktime_video_hack/blob/main/doc/technical_documentation.md
 *  - http://blog.lambdaconcept.com/post/2019-09/graywire/
 */

/*
defs:
typedef struct
{
    uint8_t type; [5 -> float32]
    uint32_t value;
} nero_nsnumber_t;

globals via wireshark:
- acc clockref  : 0x406ab10000000000
- idev clockref : 0x80370b0601000000
- acc CFTypeId clockref:  0x1068b20000000000
- idev CFTYPEId clockref: 0x4012830401000000
0x87440000
data via wireshark:
hpd1 dict data
{
    "DisplaySize": {
     "Height": float32(0x87440000), // (nmbv:NSValue[05])
     "Width": float32(0x44F00000) // (nmbv:NSValue[05])
    },
    "IsOverscanned": 1 // (bulv:Boolean)
}

hpa1 dict data:
{
    "format": [0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x6d, 0x63, 0x70, 0x6c, 0x4c, 0x00, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x6d, 0x63, 0x70, 0x6c, 0x44, 0x00, 0x00, 0x00,  0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,  0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,  0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x33, 0x63, 0x61, 0x63, 0x4c, 0x00, 0x00, 0x00,  0x00, 0x18, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x00, 0x00, 0x00, 0x00, 0x80, 0x88, 0xe5, 0x40,  0x33, 0x63, 0x61, 0x63, 0x4c, 0x00, 0x00, 0x00,  0x00, 0x18, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x80, 0x88, 0xe5, 0x40,  0x00, 0x00, 0x00, 0x00, 0x80, 0x88, 0xe5, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xdf, 0x40,  0x33, 0x63, 0x61, 0x63, 0x4c, 0x00, 0x00, 0x00,  0x00, 0x18, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xdf, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xdf, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x6d, 0x63, 0x70, 0x6c, 0x44, 0x00, 0x00, 0x00,  0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,  0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,  0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xe7, 0x40, 0x2e],
    "ScreenLatency": float64(0x3F, 0xA4, 0x7A, 0xE1, 0x47, 0xAE , 0x14, 0x7B),
    "EDIDAC3Support": uint32_t(0x00),
    "deviceUID": "4C2D600B-0000-0000-3017-010380593278",
    "deviceName": "HDMI Audio",
    "DefaultAudioChannelLayout": [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    "BufferAheadInterval": [0x06, 0xE4, 0xA5, 0x9B, 0xC4, 0x20, 0xB0, 0xB2],
    "PreferredAudioChannelLayout", [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
}

rply[amft] dict data:
{
    "Error": uint32_t(0x00),
    "PreferredAudioChannelLayout": [0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0],
    "DefaultAudioChannelLayout": [0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0],
}

sync[cvpr] dict data:
{
    "PreparedQueueHighWaterLevel": {
        "flags": uint32_t(0x01),
        "value": uint64_t(0x05),
        "timescale": uint32_t(0x1e),
        "epoch": uint64_t(0x00)
        },
    "PreparedQueueLowWaterLevel": {
        "flags": uint32_t(0x01),
        "value": uint64_t(0x03),
        "timescale": uint32_t(0x1e),
        "epoch": uint64_t(0x00),
        },
    "FormatDescription": <CMFormatDescription>
}

https://github.com/phracker/MacOSX-SDKs/blob/041600eda65c6a668f66cb7d56b7d1da3e8bcc93/MacOSX10.9.sdk/System/Library/Frameworks/CoreMedia.framework/Versions/A/Headers/CMFormatDescription.h#L78
CMMediaType: uint32_t;

https://github.com/phracker/MacOSX-SDKs/blob/041600eda65c6a668f66cb7d56b7d1da3e8bcc93/MacOSX10.9.sdk/System/Library/Frameworks/CoreMedia.framework/Versions/A/Headers/CMFormatDescription.h#L599
CMVideoDimensions: {
        width: uint32_t;
        height: uint32_t;
}

https://github.com/phracker/MacOSX-SDKs/blob/041600eda65c6a668f66cb7d56b7d1da3e8bcc93/MacOSX10.9.sdk/System/Library/Frameworks/CoreMedia.framework/Versions/A/Headers/CMFormatDescription.h#L590
CMVideoCodecType: uint32_t;

// https://github.com/phracker/MacOSX-SDKs/blob/master/MacOSX10.9.sdk/System/Library/Frameworks/CoreMedia.framework/Versions/A/Headers/CMFormatDescription.h
// CMFormatDescriptions are immutable CF objects that are used to describe media data of various types, including audio, video, and muxed media data.
CMFormatDescription: {
    mdia: CMMediaType(0x00007363);
    vdim: CMVideoDimensions([0x000002ee,0x00000536]);
    cdoc: CMVideoCodecType(0x61766331);
    extn: {
        0x31: {
           0x69: [0x1,0x64,0x0,0x28,0xff,0xe1,0x0,0x15,0x27,0x64,0x0,0x28,0xac,0x56,0x50,0x2f,0x2,0xa7,0xa9,0xa6,0xe0,0x40,0x40,0x40,0xda,0x8,0x84,0x65,0x80,0x1,0x0,0x4,0x28,0xee,0x37,0x27,0xfd,0xf8,0xf8,0x0],
           0x34: str("H.264")
        }
    };
}

// parse
//  - Picture Parameter Set (PPS)
//  - Sequence Parameter Set (SPS)

ASYN[SPRP]:
{
    "ObeyEmptyMediaMakers" = bool(true),
}
ASYN[SPRP]:
{
    "RenderEmptyMediaMakers" = bool(false)
}

*/

/*
 * Protocol Flow:
 * GlobalVars:
 *  - clockref: some uint64_t -> sniffed from official haywire adapter and moke it
 *  -
 *
 * Accessory                iDevice
 * 1: iDevice requests a PING from the ACC, if the ACC does not send an PING
 *      the iDevice will stop the handshake after CVPT
 *                  <-      MSG[PING] 
 * MSG[PING]        ->
 *    nero_ping_data_t {
          .param1 = 0x00,
          .param2 = 0x01,
      }
 *
 * 2: iDevice acknowledges the request with a PING
 *                  
 * 3: iDevice requests the our clock reference via a SYNC[CWPA]
 *    Extract some audio clock ref from iDevice and send audio clockref from Acc
 *                  <-      MSG[SYNC][CWPA]
 * MSG[RPLY][CWPA]  ->
 * We acknowledge the SYNC and send him some "dummy" clock reference
 * In addition, we need to copy over the correlationid from the CWPA into the RPLY
 * The message field is empty
 *
 * 4: Acc pushes two async msgs (hpd1, hpa1) to the iDevice and informs it about what he expects to receive
 *    These are async messages, so now response is send by the iDevice
 *    HPD1 provides information about the maximum display height and width
 *      the HPD1 package useses some dummy msg.correlationid
 *    HPA1 provides information about video and audio specific information, please checkout above
 *      the HPA1 requires the iDevice.clockref in the correlation field
 *
 * MSG[ASYN][HPA1] ->
 * MSG[ASYN][HPD1] ->
 *
 * 5: iDevice sends a SYNC[AFMT] request
 *    this requests includes information about the used audioformat
 *    the iDevice send the iDevice_clockref in the msg.correlation field
 *    the MSG[RPLY][AFMT] msg.correlationid again needs to match up with the SYNC[AFMT].cmd_correlationid
 *                  <-      MSG[SYNC][AFMT]
 *  MSG[RPLY][AFMT] ->
 *
 * 6: iDevice sends a SYNC[CVPS] request
 *    this request manages the video clock refs between the Acc and iDevice
 *    The iDevice includes it's video clock ref inside the params string
 *    The Acc sends it's video clock ref within the param string as well
 *    the acc respones with a RPLY[CVPS]
 *                  <-      MSG[SYNC][CVPT]
 *  MSG[RPLY][CVPT] ->
 *
 * 7: Acc sends ASYN[NEED] request indicating that we need sdat packets
 *    The acc includes the video clock ref within these packages
 *  MSG[ASYN][NEED] ->
 *
 * 8: iDevice sends a ASYN[SPRP] requests to the accessory, containing one key value pair
 *    We can ignore this message for now
 *    "ObeyEmptyMediaMakers" = true
 *                  <-      MSG[ASYN][SPRP]
 *
 * 9: iDevice sends a ASYN[SPRP] requests to the accessory, containing one key value pair
 *    We can ignore this message for now
 *    "RenderEmptyMedia" = false
 *                  <-      MSG[ASYN][SPRP]
 *
 * 10: iDevice sends a SYNC[CLOK] request to the accessory,
 *     the accessory creates a new clock based on an existing one. The reference
 *     from the existing one is passed inside the correlation.
 *     The Accessory creates a new one and returns it's reference within the RPLY[CLOK]
 *     After this call, the iDevice normally sends one or multiple SYNC[TIME] requests referring
 *     to the prior created clock
 *                  <-      MSG[SYNC][CLOK]
 *  MSG[RPLY][CLOK] ->
 *
 * 11: iDevice sends a SYNC[TIME] request to the accessory
 *     The iDevice requests to return time relevant information about the clock
 *     specified in msg.correlation.
 *     The RPLY[TIME] contains the cmd.correlation and the time relevant information
 *                  <-      MSG[SYNC][TIME]
 *  MSG[RPLY][TIME] ->
 *
 * 12: iDevice sends ASYN[TBAS] request, properly SetTimeBase
 *     We simply ignore this message
 *                   <-     MSG[ASYN][TBAS]
 *
 * 13: iDevice sends ASYN[TJMP] request, properly Time Jump Notification
 *     We simply ignore this message
 *                   <-     MSG[ASYN][TJMP]
 *
 * 14: iDevice sends ASYN[SRAT] - Set time rate and Anchor
 *     We simply ignore this message
 *                   <-     MSG[ASYN][SRAT]
 *
 * 15: Request more data from the device via ASYN[NEED] message
 *     After each ASYN[FEED] message, we send a ASYN[NEED]
 *
 * while (1)
 * {
 *                  <-      MSG[ASYN][FEED]
 *  MSG[ASYN][NEED] ->
 * }
 */

#endif